---
layout: post
title: "S2-052漏洞解析和补丁分析.md"
date: 2017-09-15

---


<h2><a href="#介绍" aria-hidden="true" class="anchor" id="user-content-介绍"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>介绍</h2>
<p>最近在学习反序列化之类漏洞之类的东西，之前也是看别人分析，一直没有实践，这次找到16年的一个漏洞，准备分析调试一下。漏洞环境<a href="https://github.com/zerothoughts/spring-jndi">https://github.com/zerothoughts/spring-jndi</a></p>
<h2><a href="#漏洞描述" aria-hidden="true" class="anchor" id="user-content-漏洞描述"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>漏洞描述</h2>
<p>没搜到编号，反正重点是在于学习这个漏洞。首先先把服务端跑起来，服务端代码很简单，是一个serversocket的，监听9999端口，并且抑制等待客户端socket链接过来。<br>
<a href="https://camo.githubusercontent.com/49ead91d2073d3b9b98e9875cd475696c2292223/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f34373035323930392e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/49ead91d2073d3b9b98e9875cd475696c2292223/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f34373035323930392e6a7067" alt="" data-canonical-src="http://ohsqlm7gj.bkt.clouddn.com/17-9-4/47052909.jpg" style="max-width:100%;"></a>
客户端代码
<a href="https://camo.githubusercontent.com/000696f6fa0edd973bdacf4e7f3717a6c7248c65/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f36323930323830392e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/000696f6fa0edd973bdacf4e7f3717a6c7248c65/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f36323930323830392e6a7067" alt="" data-canonical-src="http://ohsqlm7gj.bkt.clouddn.com/17-9-4/62902809.jpg" style="max-width:100%;"></a>
客户端流程如下:<br>
1.客户端代码先监听8088端口，开启一个文件下载服务。其中该地址映射的就是ExportObject.class。
2.将文件地址<a href="http://127.0.0.1:8080/ExportObject.class%E6%98%A0%E5%B0%84%E5%88%B0rmi%E6%9C%8D%E5%8A%A1%E4%B8%8A%E9%9D%A2">http://127.0.0.1:8080/ExportObject.class映射到rmi服务上面</a><br>
3.将ExportObject用JtaTransactionManager封装一下<br>
4.客户端连接服务端9999，然后发送包装后的object<br>
5.服务端接收到object，然后调用readObject
最终会弹出计算器
在分析之前有必要介绍下RMI,Remote Method Invoke 远程方法调用,用于在远端服务器上提供远程对象给客户端?什么意思，就是服务端开启这个服务，然后客户端访问服务端着个接口就可以直接拿到服务器上的对象，它的底层应该就是socket通信，然后传递一个object的。关于它的用法，可以参考这篇博客<a href="http://haolloyin.blog.51cto.com/1177454/332426/">http://haolloyin.blog.51cto.com/1177454/332426/</a><br>
使用起来也很简单，这个被传递的对象必须继承IService，然后服务端用rebind函数将这个对象和路径映射起来就可以了，服务端关键代码如下:</p>
<pre><code>IService service02 = new ServiceImpl("service02"); 
      //初始化命名空间 
      Context namingContext = new InitialContext(); 
      //将名称绑定到对象,即向命名空间注册已经实例化的远程服务对象 
      namingContext.rebind("rmi://localhost/service02", service02); 
</code></pre>
<p>客户端怎么调用，也很简单</p>
<pre><code>String url = "rmi://localhost/";  
Context namingContext = new InitialContext();  
// 检索指定的对象。 即找到服务器端相对应的服务对象存根  
IService service02 = (IService) namingContext.lookup(url + "service02"); 
</code></pre>
<p>只需要调用lookup将该路径传递进去就可以获得IService类的对象了，又做了这个基础后面理解起来就很简单了。<br>
Spring框架中的JtaTransactionManager出了问题，JtaTransactionManager实现了Serializable，并重写了readObject函数，所以当服务端运行到readObject的时候<a href="https://camo.githubusercontent.com/9370339efd42bf8368ffc5925018f3a42276aa1e/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f38323132323138352e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/9370339efd42bf8368ffc5925018f3a42276aa1e/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f38323132323138352e6a7067" alt="" data-canonical-src="http://ohsqlm7gj.bkt.clouddn.com/17-9-4/82122185.jpg" style="max-width:100%;"></a>，就会调用JtaTransactionManager类的readObject函数，跟进这个函数</p>
<pre><code>private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        this.jndiTemplate = new JndiTemplate();
        this.initUserTransactionAndTransactionManager();
        this.initTransactionSynchronizationRegistry();
    }
</code></pre>
<p>其中initUserTransactionAndTransactionManager()函数的作用看意思应该是初始化一些参数，进入这个函数<br>
<a href="https://camo.githubusercontent.com/2c53f1a90f92d3bf97e21f8d3894d140b6d732ab/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f32393637333431312e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/2c53f1a90f92d3bf97e21f8d3894d140b6d732ab/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f32393637333431312e6a7067" alt="" data-canonical-src="http://ohsqlm7gj.bkt.clouddn.com/17-9-4/29673411.jpg" style="max-width:100%;"></a>
继续跟进lookupUserTransaction这个函数
<a href="https://camo.githubusercontent.com/019c6cdd914a31e1a19b8f3823fc55d04e52afa7/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f33303031323831372e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/019c6cdd914a31e1a19b8f3823fc55d04e52afa7/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f33303031323831372e6a7067" alt="" data-canonical-src="http://ohsqlm7gj.bkt.clouddn.com/17-9-4/30012817.jpg" style="max-width:100%;"></a>
最终执行了lookup，如果看了前面的话应该还记得需要跟一个rmi路径，这个路径其实在ExploitClient中就设置了
<a href="https://camo.githubusercontent.com/13351cc7c5959e2e479c1dbca8f14b27b582ae2d/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f38373733393237352e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/13351cc7c5959e2e479c1dbca8f14b27b582ae2d/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f38373733393237352e6a7067" alt="" data-canonical-src="http://ohsqlm7gj.bkt.clouddn.com/17-9-4/87739275.jpg" style="max-width:100%;"></a>
所以最终被带入到lookup里面了，那么会怎样？由于路径是rmi://127.0.0.1:1099/Object ,那怎么样？new 一个Object呗，由于前面用bind将ExportObject和Object绑定了，那么就是执行ExportObject的构造函数咯，构造函数里面就是弹出一个计算器，至此，整个逻辑调通。
<a href="https://camo.githubusercontent.com/b2a4673ac3e7eec5e553173648def507bd34ff9b/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f38383833303337332e6a7067" target="_blank"><img src="https://camo.githubusercontent.com/b2a4673ac3e7eec5e553173648def507bd34ff9b/687474703a2f2f6f6873716c6d37676a2e626b742e636c6f7564646e2e636f6d2f31372d392d342f38383833303337332e6a7067" alt="" data-canonical-src="http://ohsqlm7gj.bkt.clouddn.com/17-9-4/88830373.jpg" style="max-width:100%;"></a></p>
<h2><a href="#流程总结" aria-hidden="true" class="anchor" id="user-content-流程总结"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流程总结</h2>
<p>用一张图来总结整个流程比较好，这里借鉴了Seebug上某片文章的图<br>
<a href="https://camo.githubusercontent.com/a4abc2fecd25bc61321a905699d367f57387f83c/68747470733a2f2f696d616765732e7365656275672e6f72672f636f6e74656e742f696d616765732f323031372f30362f31343936383335313939343832342e706e672d7733333173" target="_blank"><img src="https://camo.githubusercontent.com/a4abc2fecd25bc61321a905699d367f57387f83c/68747470733a2f2f696d616765732e7365656275672e6f72672f636f6e74656e742f696d616765732f323031372f30362f31343936383335313939343832342e706e672d7733333173" alt="" data-canonical-src="https://images.seebug.org/content/images/2017/06/14968351994824.png-w331s" style="max-width:100%;"></a></p>
<h2><a href="#学习心得" aria-hidden="true" class="anchor" id="user-content-学习心得"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>学习心得：</h2>
<p>自己还真的很菜，道阻且长，加油，趁着自己闲下来的时间好好学习。</p>
</article>
  </div>

  </div>
